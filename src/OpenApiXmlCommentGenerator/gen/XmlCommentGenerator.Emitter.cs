// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.

using DocFx.XmlComments;
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.IO;
using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;

namespace Microsoft.AspNetCore.OpenApi.SourceGenerators;

public sealed partial class XmlCommentGenerator : IIncrementalGenerator
{
    public static string GeneratedCodeConstructor => $@"System.CodeDom.Compiler.GeneratedCodeAttribute(""{typeof(XmlCommentGenerator).Assembly.FullName}"", ""{typeof(XmlCommentGenerator).Assembly.GetName().Version}"")";
    public static string GeneratedCodeAttribute => $"[{GeneratedCodeConstructor}]";

    internal static string GenerateXmlCommentSupportSource(IEnumerable<(string, string?, XmlComment?)> cacheEntries, ImmutableArray<(AddOpenApiInvocation Source, int Index, ImmutableArray<InterceptableLocation?> Elements)> groupedAddOpenApiInvocations) => $$"""
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
#nullable enable

namespace System.Runtime.CompilerServices
{
    {{GeneratedCodeAttribute}}
    [AttributeUsage(AttributeTargets.Method, AllowMultiple = true)]
    file sealed class InterceptsLocationAttribute : System.Attribute
    {
        public InterceptsLocationAttribute(int version, string data)
        {
        }
    }
}

namespace Microsoft.AspNetCore.OpenApi.Generated
{
    using DocFx.XmlComments;
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Reflection;
    using System.Text.Json;
    using System.Threading;
    using System.Threading.Tasks;
    using Microsoft.AspNetCore.OpenApi;
    using Microsoft.AspNetCore.Mvc.Controllers;
    using Microsoft.Extensions.DependencyInjection;
    using Microsoft.OpenApi.Models;
    using Microsoft.OpenApi.Any;

    file class XmlComment
    {
        public string? Summary { get; set; }
        public string? Description { get; set; }
        public string? Returns { get; set; }
        public IOpenApiAny? Example { get; set; }
    }

    file static class XmlCommentCache
    {
        private static Dictionary<(Type?, string?), XmlComment>? _cache;
        public static Dictionary<(Type?, string?), XmlComment> Cache
        {
            get
            {
                if (_cache is null)
                {
                    _cache = GenerateCacheEntries();
                }
                return _cache;
            }
        }

        private static Dictionary<(Type?, string?), XmlComment> GenerateCacheEntries()
        {
{{GenerateCacheEntries(cacheEntries)}}
        }
    }

    file class XmlCommentOperationTransformer : IOpenApiOperationTransformer
    {
        public Task TransformAsync(OpenApiOperation operation, OpenApiOperationTransformerContext context, CancellationToken cancellationToken)
        {
            System.Diagnostics.Debugger.Break();
            if (context.Description.ActionDescriptor is ControllerActionDescriptor controllerActionDescriptor)
            {
                if (XmlCommentCache.Cache.TryGetValue((controllerActionDescriptor.MethodInfo.DeclaringType, controllerActionDescriptor.MethodInfo.Name), out var methodComment))
                {
                    operation.Summary = methodComment.Summary;
                    operation.Description = methodComment.Description;
                }
            }

            var methodInfo = context.Description.ActionDescriptor.EndpointMetadata.OfType<MethodInfo>().SingleOrDefault();
            if (methodInfo is not null)
            {
                if (XmlCommentCache.Cache.TryGetValue((methodInfo.DeclaringType, methodInfo.Name), out var methodComment))
                {
                    operation.Summary = methodComment.Summary;
                    operation.Description = methodComment.Description;
                }
            }
            return Task.CompletedTask;
        }
    }

    file class XmlCommentSchemaTransformer : IOpenApiSchemaTransformer
    {
        public Task TransformAsync(OpenApiSchema schema, OpenApiSchemaTransformerContext context, CancellationToken cancellationToken)
        {
            if (context.JsonPropertyInfo is { AttributeProvider: PropertyInfo propertyInfo })
            {
                if (XmlCommentCache.Cache.TryGetValue((propertyInfo.DeclaringType, propertyInfo.Name), out var propertyComment))
                {
                    schema.Description = propertyComment.Returns ?? propertyComment.Summary;
                    if (propertyComment.Example is not null)
                    {
                        schema.Example = propertyComment.Example;
                    }
                }
            }
            if (XmlCommentCache.Cache.TryGetValue((context.JsonTypeInfo.Type, null), out var typeComment))
            {
                schema.Description = typeComment.Summary;
                if (schema.Example is not null)
                {
                    schema.Example = typeComment.Example;
                }
            }
            return Task.CompletedTask;
        }
    }

    file static class GeneratedServiceCollectionExtensions
    {
{{GenerateAddOpenApiInterceptions(groupedAddOpenApiInvocations)}}
    }
}
""";

    internal static string GetAddOpenApiInterceptor(AddOpenApiOverloadVariant overloadVariant) => overloadVariant switch
    {
        AddOpenApiOverloadVariant.AddOpenApi => """
        public static IServiceCollection AddOpenApi(this IServiceCollection services)
                {
                    return services.AddOpenApi("v1", options =>
                    {
                        options.AddSchemaTransformer(new XmlCommentSchemaTransformer());
                        options.AddOperationTransformer(new XmlCommentOperationTransformer());
                    });
                }
        """,
        AddOpenApiOverloadVariant.AddOpenApiDocumentName => """
        public static IServiceCollection AddOpenApi(this IServiceCollection services, string documentName)
                {
                    return services.AddOpenApi(documentName, options =>
                    {
                        options.AddSchemaTransformer(new XmlCommentSchemaTransformer());
                        options.AddOperationTransformer(new XmlCommentOperationTransformer());
                    });
                }
        """,
        AddOpenApiOverloadVariant.AddOpenApiDocumentNameConfigureOptions => """
        public static IServiceCollection AddOpenApi(this IServiceCollection services, string documentName, Action<OpenApiOptions> configureOptions)
                {
                    // This overload is not intercepted.
                    return OpenApiServiceCollectionExtensions.AddOpenApi(services, documentName, options =>
                    {
                        configureOptions(options);
                        options.AddSchemaTransformer(new XmlCommentTransformer());
                        options.AddOperationTransformer(new XmlCommentOperationTransformer());
                    });
                }
        """,
        _ => throw new InvalidOperationException("Invalid overload variant for `AddOpenApi`.")
    };

    internal static string GenerateAddOpenApiInterceptions(ImmutableArray<(AddOpenApiInvocation Source, int Index, ImmutableArray<InterceptableLocation?> Elements)> groupedAddOpenApiInvocations)
    {
        var writer = new StringWriter();
        var codeWriter = new CodeWriter(writer, baseIndent: 2);
        foreach (var (source, _, locations) in groupedAddOpenApiInvocations)
        {
            foreach (var location in locations)
            {
                if (location is not null)
                {
                    codeWriter.WriteLine(location.GetInterceptsLocationAttributeSyntax());
                }
            }
            codeWriter.WriteLine(GetAddOpenApiInterceptor(source.Variant));
        }
        return writer.ToString();
    }

    internal static string GenerateCacheEntries(IEnumerable<(string, string?, XmlComment?)> cacheEntries)
    {
        var writer = new StringWriter();
        var codeWriter = new CodeWriter(writer, baseIndent: 3);
        codeWriter.WriteLine("var _cache = new Dictionary<(Type?, string?), XmlComment>();");
        codeWriter.WriteLine("XmlComment xmlComment;");
        foreach (var (type, member, comment) in cacheEntries)
        {
            if (comment is not null)
            {
                var typeKey = $"(typeof({type})";
                var memberKey = member is not null ? $"nameof({type}.{member})" : "null";
                codeWriter.WriteLine("xmlComment = new XmlComment();");
                if (comment.Summary is not null)
                {
                    codeWriter.WriteLine($"xmlComment.Summary = {SymbolDisplay.FormatLiteral(comment.Summary, true)};");
                }
                if (comment.Description is not null)
                {
                    codeWriter.WriteLine($"xmlComment.Description = {SymbolDisplay.FormatLiteral(comment.Description, true)};");
                }
                if (comment.Returns is not null)
                {
                    codeWriter.WriteLine($"xmlComment.Returns = {SymbolDisplay.FormatLiteral(comment.Returns, true)};");
                }
                if (comment.Examples.FirstOrDefault() is { } example)
                {
                    codeWriter.WriteLine($"xmlComment.Example = {GenerateExampleValue(example, comment.Type)};");
                }
                codeWriter.WriteLine($"_cache.Add({typeKey}, {memberKey}), xmlComment);");
            }
        }
        codeWriter.WriteLine("return _cache;");
        return writer.ToString();
    }

    private static string GenerateExampleValue(string? example, ITypeSymbol type)
    {
        if (example == null)
        {
            return "new OpenApiNull()";
        }
        return type.SpecialType switch
        {
            SpecialType.System_String => $"new OpenApiString({SymbolDisplay.FormatLiteral(example, false)})",
            SpecialType.System_DateTime => $"new OpenApiDateTime(System.DateTime.Parse({SymbolDisplay.FormatLiteral(example, true)}))",
            SpecialType.System_Boolean => $"new OpenApiBoolean({SymbolDisplay.FormatLiteral(example, false)})",
            SpecialType.System_Int32 => $"new OpenApiInteger({SymbolDisplay.FormatLiteral(example, false)})",
            SpecialType.System_Int64 => $"new OpenApiLong({SymbolDisplay.FormatLiteral(example, false)})",
            SpecialType.System_Double => $"new OpenApiDouble({SymbolDisplay.FormatLiteral(example, false)})",
            SpecialType.System_Single => $"new OpenApiFloat({SymbolDisplay.FormatLiteral(example, false)})",
            _ => HandleExampleWithoutSpecialType(example, type)
        };

        static string HandleExampleWithoutSpecialType(string? example, ITypeSymbol type)
        {
            if (type is INamedTypeSymbol namedType)
            {
                if (namedType.IsGenericType && namedType.TypeArguments.Length == 1)
                {
                    var typeArgument = namedType.TypeArguments[0];
                    if (namedType.Name == "IEnumerable" || namedType.Name == "ICollection" || namedType.Name == "IList")
                    {
                        return $"new OpenApiArray({GenerateExampleValue(example, typeArgument)})";
                    }
                    if (namedType.Name == "IDictionary")
                    {
                        return $"new OpenApiObject(new Dictionary<string, IOpenApiAny> {{ {{ \"key\", {GenerateExampleValue(example, typeArgument)} }} }})";
                    }
                }
                else if (namedType.Name == "DateTimeOffset")
                {
                    return $"new OpenApiDateTime(System.DateTimeOffset.Parse({SymbolDisplay.FormatLiteral(example, true)}))";
                }
                else
                {
                    return $"new OpenApiObject({SymbolDisplay.FormatLiteral(example, false)})";
                }
            }
            return "new OpenApiNull()";
        }
    }

    internal static void EmitXmlCommentCache(SourceProductionContext context, IEnumerable<(string, string?, XmlComment?)> comments, ImmutableArray<(AddOpenApiInvocation Source, int Index, ImmutableArray<InterceptableLocation?> Elements)> groupedAddOpenApiInvocations)
    {
        context.AddSource("OpenApiXmlCommentSupport.generated.cs", GenerateXmlCommentSupportSource(comments, groupedAddOpenApiInvocations));
    }
}
